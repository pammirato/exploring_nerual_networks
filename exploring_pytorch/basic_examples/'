import torch
import torch.utils.data
from torch.autograd import Variable
import torch.nn.functional as F
import active_vision_dataset_processing.data_loading.active_vision_dataset_pytorch as AVD 
import active_vision_dataset_processing.data_loading.transforms as AVD_transforms
from PreDefinedSquareImageNet import PreDefinedSquareImageNet
import time


data_path = '/playpen/ammirato/Data/RohitData/'
num_classes = 2
learning_rate = .001
batch_size = 32 
max_iterations = 100 
image_size = [32,32,3]
cuda = True
chosen_ids = [0,5]


#time_start = time.time()

#CREATE TRAIN/TEST splits
#label transforms
back_trans = AVD_transforms.AddBackgroundBoxes(num_to_add=2,
                                              box_dimensions_range=[100,100,200,200])
pick_trans = AVD_transforms.PickInstances(chosen_ids)
perturb_trans = AVD_transforms.AddPerturbedBoxes(num_to_add=7,
                                                changes = [[-50,10],
                                                           [-50,10], 
                                                           [-50,10], 
                                                           [-50,10]])
validate_trans =AVD_transforms.ValidateMinMaxBoxes()
ids_trans = AVD_transforms.MakeIdsConsecutive(chosen_ids)

target_trans = AVD_transforms.Compose([perturb_trans,
                                       back_trans,  
                                       pick_trans,
                                       validate_trans])

#image transforms
norm_trans = AVD_transforms.NormalizePlusMinusOne()
resize_trans = AVD_transforms.ResizeImage(image_size[0:2],'fill')
to_tensor_trans = AVD_transforms.ToTensor()
image_trans = AVD_transforms.Compose([resize_trans,
                                      to_tensor_trans,
                                      norm_trans])

train_set = AVD.AVD_ByBox(root='/playpen/ammirato/Data/RohitData/',
                             scene_list=['Home_014_1'],
                             transform=image_trans,
                             target_transform=target_trans,
                             classification=True)
#test_set = AVD.AVD_ByBox(root='/playpen/ammirato/Data/RohitData/',
#                             scene_list=['Home_014_2'],
#                             transform=image_trans,
#                             target_transform=target_trans,
#                             classification=True)



trainloader = torch.utils.data.DataLoader(train_set,batch_size=batch_size,shuffle=True,
                                          num_workers=2, collate_fn=AVD.collate)
trainiter = iter(trainloader)



#time_splits = time.time() - time_start





#Define model, optimizer, and loss function
model = PreDefinedSquareImageNet(image_size,num_classes)
if cuda:
    model.cuda()

optimizer = torch.optim.SGD(model.parameters(),lr=learning_rate)
loss_fn = torch.nn.NLLLoss()


#time_model = time.time() - time_start


#print 'Time splits: ' + str(time_splits - time_start)


index = 0
#TRAIN LOOP
for il in range(max_iterations):


    #time_start = time.time()

    #batch = train_set[index:index+batch_size]
    batch = trainiter.next()

    
    #time_get_batch = time.time() - time_start

    batch_imgs = batch[0]
    batch_labels = batch[1]

    #batch_imgs = [img.unsqueeze(0) for img,_ in batch]
    #batch_imgs = torch.cat(batch_imgs)
    #batch_labels = [torch.LongTensor([label]) for _,label in batch]
    #for i  in range(len(batch_labels)): 
    #    if batch_labels[i].numpy() > 1: 
    #        batch_labels[i] = torch.LongTensor([1])
    #batch_labels = torch.cat(batch_labels) 

    #time_batch_setup = time.time() - time_start

    if cuda:
        batch_imgs, batch_labels = batch_imgs.cuda(), batch_labels.cuda() 

    #time_batch_cuda = time.time() - time_start

    optimizer.zero_grad()     
    y_pred = model(Variable(batch_imgs))
    loss = loss_fn.forward(y_pred,Variable(batch_labels))

    loss.backward()
    optimizer.step()
    
    #time_step = time.time() - time_start

    #print ('Time get_batch: ' + str(time_get_batch) + 
    #       'Time setup: ' + str(time_batch_setup) +
    #       'cuda: ' + str(time_batch_cuda) + 
    #       'step: ' + str(time_step))


    if il % 10 == 0:
        print 'Loss : ' + str(loss.data[0])    

    #index = index+batch_size
    #if(index > len(train_set)):
    #    index = 0


